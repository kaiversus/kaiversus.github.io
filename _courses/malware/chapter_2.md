---
layout: course
title: "Chapter 2: Portable Executable File - PE file"
category: Malware
description: "Understand the PE file structure and RE basics by using PE-bear and HxD to analyze files."
author: Kaiversus
date: 2026-1-2
difficulty: Intermediate
---

## What is the PE ?

The COFF file and the PE file

- **The Common Object File Format (COFF)** is a format for executable, object code, and shard library computer files used on Unix systems. COFF and its variants continue to be used on some Unix-like systems, on Microsoft Windows (Portable Executable), in UEFI environments and in some embedded development systems. [1]
    - *Inclusion, **COFF** is a standard file structure for compiled code and libraries that influenced later executable formats and is still used in some environments today.*
- **Portable Executable (PE)** is a file format for native executable code on 32-bit and 64-bit Windows operating systems, as well as in UEFI environments. It is used for native executables (.exe, .com), system drivers (.sys, .drv) and many other types of files. The PE format supports storing the data required to load and start an operating system process - including references to dynamic link libraries, tables for importing and exporting application programming interface (API) functions, resource management data and thread-local storage (TLS) information[2]
    - ***PE** is the main Windows executable format for programs and drivers, and it includes the metadata Windows needs to load the file, resolve imports, and start the process.*

## Structure Overview

A typical PE file follows the structure in the following figure:

<img src="/assets/images/courses/malware/chapter2/image.png" width="40%" style="display: block; margin: 0 auto;">

If we use PE-bear to open the PE file, we will see the same thing:

![{A45BCE8C-243D-43C0-A865-28D08207E9F7}.png](/assets/images/courses/malware/chapter2/A45BCE8C-243D-43C0-A865-28D08207E9F7.png)

### DOS Headers

**Overview**

The DOS Header (or MS-DOS header) is a 64-byte structure at the beginning of a PE file. It exists for backward compatibility: on MS‑DOS, the DOS stub will be executed (often showing “This program cannot be run in DOS mode”), while on Windows the loader uses the DOS header (e.g., `e_lfanew`) to locate the PE/NT headers; without it, the file is typically considered invalid and may fail to load.

*So, why “without DOS header make the file fail to load”?* 

⇒ *Because the DOS header contains the MZ signature and e_lfanew, the loader can find the PE header and load the file. Without it, the OS will usually treat the file as an invalid executable.*

**Structure**

As mentioned before, DOS header long 64 bytes, we can look at the contents of that structure at the `IMAGE_DOS_HEADER` structure definition from `winnt.h`  file (may it is located at C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um ) if you installed the Windows SDK with Visual Studio (C/C++):

```c
typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
```

This structure is important to the PE loader on MS-DOS, however only 2 members of it are important to the PE loader on Windows Systems:

- `e_magic` : this is the first member of the DOS Header, it occupies a WORD (2 bytes) and it usually called the **magic number**. It has a fixed value of `0x5A4D`  or `MZ` in ASCII and serves a signature that marks the file as an MS-DOS executable
- `e_lfanew` : this is the last member of the DOS Header, it is located `0x3C`  and holds an offset to the start of the NT Headers. It is important because it tells the loader where to look for the file header.

The following picture shows contents of the DOS Header in an actual PE file using PE-bear:

![{D80A5B4E-3733-4A86-91F0-592B9DB646E4}.png](/assets/images/courses/malware/chapter2/D80A5B4E-3733-4A86-91F0-592B9DB646E4.png)

As you can see, the first member is the magic number with value `5A4D` , and the last member of the header at offset 0x3C is given the name “File address of new exe header” and it has value 100, We can jump to file offset `0x100` to reach the start of the NT headers (the `PE\0\0` signature).”

![{A1CFDBFB-23E9-4B51-AF8D-5744AC7CA602}.png](/assets/images/courses/malware/chapter2/A1CFDBFB-23E9-4B51-AF8D-5744AC7CA602.png)

### DOS Stub

**Summary**: The DOS Stub is a small MS-DOS program that prints an error message “ This program cannot be run in DOS mode.” if you try to execute the file on MS-DOS. However, the message can changed by the user during compile time. 

That’s all we need to know about the DOS stub!!!

<!-- ### Rich Header

read this : https://0xrick.github.io/win-internals/pe3/ -->

### NT Headers (IMAGE_NT_Headers)

```c
typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
```

NT Headers is a structure defined in `winnt.h`  as `_IMAGE_NT_HEADERS64` (for 64-bit/`PE32+`) and `_IMAGE_NT_HEADERS`  (for 32-bit/`PE32`), by looking at its definition we can see that it has three members:

- Signature (DWORD)
- FileHeader (IMAGE_FILE_HEADER)
- OptionalHeader (IMAGE_OPTIONAL_HEADER64/32)

So we will break down three members of NT Headers:

**Signature**

This member occupies a DWORD - 4 bytes, and it always has a fixed value of `0x50450000`  which translate to `PE\0\0`  in ASCII.

This is a screenshot from PE-bear showing the PE signature:

![{6ACA34B0-93D2-422A-BCCD-A98303544F71}.png](/assets/images/courses/malware/chapter2/6ACA34B0-93D2-422A-BCCD-A98303544F71.png)

**File Header (IMAGE_FILE_HEADER)**

Also called “The COFF File Header”, this member holds some information about the PE file

We can see the definition in `winnt.h` :

```c
typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
```

File Header consists of 7 members:

- **Machine**: this is a number that indicates the type of machine (CPU type) the executable , it can take many possible values, but we just consider 2 values `0x8664` for `AMD64` and `0x14c` for `i386`, that’s is enough for our purpose. If you want to know more, you can check the Official Microsoft Documentation.
- **NumberOfSections**: the number of sections
- **TimeDateStamp**: the low 32 bits of the number of seconds since 00:00 January 1, 1970 which indicates when the file was created
- **PointerToSymbolTable and NumberOfSymbols:** two fields hold the file offset to COFF symbols table and the number of entries it that symbols table, and two fields get set to 0 because COFF debugging information is deprecated.
- **SizeOfOptionalHeader:** the size of the Optional Header
- **Characteristics:** The flags that indicate the attributes of the file. If you want to check =>https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#characteristics

Here’s the File Header of an actual PE file:

![{3AFA70CA-C8E9-4569-8707-764A60A441DB}.png](/assets/images/courses/malware/chapter2/3AFA70CA-C8E9-4569-8707-764A60A441DB.png)

**Optional Header (IMAGE_OPTIONAL_HEADER)**

The Option Header is the most important header of the NT headers, because it provide specific information to be able to load and run the executable. Its called the Optional Header because some file don’t have it, but the image file need it. Option Header doesn’t have a fixed size, so that is why `IMAGE_FILE_HEADER.SizeOfOptionalHeader` member exists.

The structure of Optional Header for 32-bit and 64-bit :

```c
typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;
```

```cpp
typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;
```

The first 8 members of the Optional Header structure are standard for every implementation of the COFF file format, and the rest of the header is standard COFF defined by Microsoft, they are needed by the Windows PE Loader and Linker.

The two differences of two version:

- **The number of members defined within the structure:** `IMAGE_OPTIONAL_HEADER32` has 31 members while `IMAGE_OPTIONAL_HEADER64` has 30 members (has `BaseOfData` member, it holds an RVA of the beginning of the data section)
- **The data type of some of the members: 5 members (** **`ImageBase`,**  **`SizeOfStackReserve` , `SizeOfStackCommit`,**  **`SizeOfHeapReserve`,**  **`SizeOfHeapCommit`) are defined as `DWORD`  in the 32-bit version but `ULONGLONG`  in the 64-bit version.**

**Optional Header Standard Fields**

| fset | Size | Field | Description |
| --- | --- | --- | --- |
| 0 | 2 | Magic | The unsigned integer that identifies the state of the image file. The most common number is 0x10B (PE32), 0x107 identifies it as a ROM image, and 0x20B identifies it as a PE32+ executable. |
| 2 | 1 | MajorLinkerVersion | The linker major version number. |
| 3 | 1 | MinorLinkerVersion | The linker minor version number. |
| 4 | 4 | SizeOfCode | The size of the code (`.text`) section, or the sum of all code sections if there are multiple sections. |
| 8 | 4 | SizeOfInitializedData | The size of the initialized data section (`.data`), or the sum of all such sections if there are multiple data sections. |
| 12 | 4 | SizeOfUninitializedData | The size of the uninitialized data section (`.bss`), or the sum of all such sections if there are multiple BSS sections. |
| 16 | 4 | AddressOfEntryPoint | The address of the entry point relative to the image base when the executable file is loaded into memory. For program images, this is the starting address. For device drivers, this is the address of the initialization function. An entry point is optional for DLLs. When no entry point is present, this field must be zero. |
| 20 | 4 | BaseOfCode | The address that is relative to the image base of the beginning-of-code section when it is loaded into memory. |
| ffset | Size | Field | Description |
| 24 | 4 | BaseOfData **(`PE32` Only)** | The address that is relative to the image base of the beginning-of-data section when it is loaded into memory. |

**Optional Header Windows-Specific Fields** 

| Offset (PE32/ PE32+) | Size (PE32/ PE32+) | Field | Description |
| --- | --- | --- | --- |
| 28/24 | 4/8 | ImageBase | The preferred address of the first byte of image when loaded into memory; must be a multiple of 64 K. The default for DLLs is 0x10000000.  |
| 32/32 | 4 | SectionAlignment | The alignment (in bytes) of sections when they are loaded into memory. It must be greater than or equal to FileAlignment. The default is the page size for the architecture. |
| 36/36 | 4 | FileAlignment | The alignment factor (in bytes) that is used to align the raw data of sections in the image file. The value should be a power of 2 between 512 and 64 K, inclusive. The default is 512. If the SectionAlignment is less than the architecture's page size, then FileAlignment must match SectionAlignment. |
| 40/40 | 2 | MajorOperatingSystemVersion | The major version number of the required operating system. |
| 42/42 | 2 | MinorOperatingSystemVersion | The minor version number of the required operating system. |
| 44/44 | 2 | MajorImageVersion | The major version number of the image. |
| 46/46 | 2 | MinorImageVersion | The minor version number of the image. |
| 48/48 | 2 | MajorSubsystemVersion | The major version number of the subsystem. |
| 50/50 | 2 | MinorSubsystemVersion | The minor version number of the subsystem. |
| 52/52 | 4 | Win32VersionValue | Reserved, must be zero. |
| 56/56 | 4 | SizeOfImage | The size (in bytes) of the image, including all headers, as the image is loaded in memory. It must be a multiple of SectionAlignment. |
| 60/60 | 4 | SizeOfHeaders | The combined size of an MS-DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment. |
| 64/64 | 4 | CheckSum | The image file checksum. The algorithm for computing the checksum is incorporated into IMAGHELP.DLL. The following are checked for validation at load time: all drivers, any DLL loaded at boot time, and any DLL that is loaded into a critical Windows process. |
| 68/68 | 2 | Subsystem | The subsystem that is required to run this image.  |
| 70/70 | 2 | DllCharacteristics | This field defines some characteristics of the executable image file. |
| 72/72 | 4/8 | SizeOfStackReserve | The size of the stack to reserve. Only SizeOfStackCommit is committed; the rest is made available one page at a time until the reserve size is reached. |
| 76/80 | 4/8 | SizeOfStackCommit | The size of the stack to commit. |
| 80/88 | 4/8 | SizeOfHeapReserve | The size of the local heap space to reserve. Only SizeOfHeapCommit is committed; the rest is made available one page at a time until the reserve size is reached. |
| 84/96 | 4/8 | SizeOfHeapCommit | The size of the local heap space to commit. |
| 88/104 | 4 | LoaderFlags | Reserved, must be zero. |
| 92/108 | 4 | NumberOfRvaAndSizes | The number of data-directory entries in the remainder of the optional header. Each describes a location and size. |

The following is the Optional Header of an actual PE-file in PE-bear:

![{55E40A44-34B5-4211-BCD6-FC44BF30C153}.png](/assets/images/courses/malware/chapter2/55E40A44-34B5-4211-BCD6-FC44BF30C153.png)

As you can see, we have some information from picture above. The first one, the `Magic`  value is `0x10B` means PE32 executable. The second one, the entry point RVA is `0x12C1` and the code section start RVA is `0x1000`, it follows the alignment defined by the `SectionAlignment` field which has the value of `0x1000` , a rule you should remember is the `SectionAlignment`  always greater or equal to the `FileAlignment` . The `Subsystem` is set to `3`  because this is a console application

**Data Directories**

The last member of the `IMAGE_OPTIONAL_HEADER` was an array of `IMAGE_DATA_DIRECTORY` and this structure defined as follow:

```cpp
IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
```

`IMAGE_NUMBEROF_DIRECTORY_ENTRIES`  is a constant defined with the value `16` that means this array have up to `16` `IMAGE_DATA_DIRECTORY`  entries

An `IMAGE_DATA_DIRETORY` structure is defines as follow:

```cpp
typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
```

It has two members: the first one is an **RVA pointing to the start** of the Data Directory and the second one is **the size** of the Data Directory

Basically, a Data Directory is a block of data located within one of the sections of the PE file, it contains useful information needed by the loader (ex: contains a list of external functions imported from other libraries,…)

**Note**: Not all Data Directories have the same structure, the `IMAGE_DATA_DIRECTORY.VirtualAddress` points to the Data Directory, however the type of that directory is what determines how that chunk of data should be parsed

Here’s a list of Data Directories defined in `winnt.h` , each one is represented by a number, which is used as an index in the Data Directory array:

```cpp
#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor
```

If you are wondering *Why the definition above has 15 entries, while `IMAGE_NUMBEROF_DIRECTORY_ENTRIES`* *is defined as  `16` , here’s why?*

⇒ This is because the index 15 is reserved and not use, so it is set to 0 (NULL). 

And, If we take a look at the contents of `IMAGE_OPTIONAL_HEADER.DataDirectory` of actual PE file, we might see entries like this:

![{B82ECFF8-ED06-4948-83E1-653B44D70AC3}.png](/assets/images/courses/malware/chapter2/B82ECFF8-ED06-4948-83E1-653B44D70AC3.png)

This means that this specific Data Directory is not used in the executable file (the program does not use any other external libraries)

### Sections and Section Headers

**Sections**

Sections are the containers of the actual data of the executable file, they occupy the rest of the PE file after the headers, precisely after the section headers. Some sections have special names that indicate their purpose, we’ll go over some of them and the full list of section names here: https://learn.microsoft.com/en-us/windows/win32/debug/pe-format

- `.text`: Contains the executable code of the program.
- `.data`: Contains the initialized data.
- `.bss`: Contains uninitialized data.
- `.rdata`: Contains read-only initialized data.
- `.edata`: Contains the export tables.
- `.idata`: Contains the import tables.
- `.reloc`: Contains image relocation information.
- `.rsrc`: Contains resources used by the program, these include images, icons or even embedded binaries.
- `.tls`: (**T**hread **L**ocal **S**torage), provides storage for every executing thread of the program.

![{1B76764F-CB33-4620-8E30-25102EF24116}.png](/assets/images/courses/malware/chapter2/1B76764F-CB33-4620-8E30-25102EF24116.png)

**Section Headers**

After the Optional Header and before the sections comes the Section Headers which contain information about the sections of the PE file

A Section Header is a structure named `IMAGE_SECTION_HEADER` defined in `winnt.h`  as follows:

```c
typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
```

| Offset | Size | Field | Description |
| --- | --- | --- | --- |
| 0 | 8 | Name | An 8-byte, null-padded UTF-8 encoded string. If the string is exactly 8 characters long, there is no terminating null. For longer names, this field contains a slash (/) that is followed by an ASCII representation of a decimal number that is an offset into the string table. Executable images do not use a string table and do not support section names longer than 8 characters. Long names in object files are truncated if they are emitted to an executable file. |
| 8 | 4 | VirtualSize | The total size of the section when loaded into memory. If this value is greater than SizeOfRawData, the section is zero-padded. This field is valid only for executable images and should be set to zero for object files. |
| 12 | 4 | VirtualAddress | For executable images, the address of the first byte of the section relative to the image base when the section is loaded into memory. For object files, this field is the address of the first byte before relocation is applied; for simplicity, compilers should set this to zero. Otherwise, it is an arbitrary value that is subtracted from offsets during relocation. |
| 16 | 4 | SizeOfRawData | The size of the section (for object files) or the size of the initialized data on disk (for image files). For executable images, this must be a multiple of FileAlignment from the optional header. If this is less than VirtualSize, the remainder of the section is zero-filled. Because the SizeOfRawData field is rounded but the VirtualSize field is not, it is possible for SizeOfRawData to be greater than VirtualSize as well. When a section contains only uninitialized data, this field should be zero. |
| 20 | 4 | PointerToRawData | The file pointer to the first page of the section within the COFF file. For executable images, this must be a multiple of FileAlignment from the optional header. For object files, the value should be aligned on a 4-byte boundary for best performance. When a section contains only uninitialized data, this field should be zero. |
| 24 | 4 | PointerToRelocations | The file pointer to the beginning of relocation entries for the section. This is set to zero for executable images or if there are no relocations. |
| 28 | 4 | PointerToLinenumbers | The file pointer to the beginning of line-number entries for the section. This is set to zero if there are no COFF line numbers. This value should be zero for an image because COFF debugging information is deprecated. |
| 32 | 2 | NumberOfRelocations | The number of relocation entries for the section. This is set to zero for executable images. |
| 34 | 2 | NumberOfLinenumbers | The number of line-number entries for the section. This value should be zero for an image because COFF debugging information is deprecated. |
| 36 | 4 | Characteristics | The flags that describe the characteristics of the section. For more information, see [Section Flags](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags). |

Here’s the Section Header of actual PE-file in PE-bear:

![{77892C34-7BF4-4B4B-A44B-457836533FB9}.png](/assets/images/courses/malware/chapter2/77892C34-7BF4-4B4B-A44B-457836533FB9.png)

The `Raw Addr`  and  `Virtual Addr` fields are correspond to `IMAGE_SECTION_HEADER.PointerToRawData` and `IMAGE_SECTION_HEADER.VirtualAddress` , `Raw Size` and `Virtual Size` correspond to `IMAGE_SECTION_HEADER.SizeOfRawData` and `IMAGE_SECTION_HEADER.VirtualSize`

### **PE Imports (Import Directory Table, ILT, IAT)**

The Import Directory Table is a Data Directory located at the beginning of the `.idata` section

It consists of an array of `IMAGE_IMPORT_DESCRIPTOR` structure, Each entry corresponds to a DLL and doesn’t have a fixed size, so the last `IMAGE_IMPORT_DESCRIPTOR` entry is zeroed-out (NULL - Padded) to mark the end of the array.

```c
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            // 0 for terminating null import descriptor
        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    } DUMMYUNIONNAME;
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;
```

| Offset | Size | Field | Description |
| --- | --- | --- | --- |
| 0 | 4 | Import Lookup Table RVA (Characteristics) | The RVA of the import lookup table (ILT). This table contains a name or ordinal for each import |
| 4 | 4 | Time/Date Stamp | The stamp that is set to zero until the image is bound. After the image is bound, this field is set to the time/data stamp of the DLL. |
| 8 | 4 | Forwarder Chain | The index of the first forwarder reference. |
| 12 | 4 | Name RVA | The address of an ASCII string that contains the name of the DLL. This address is relative to the image base. |
| 16 | 4 | Import Address Table RVA (Thunk Table) | The RVA of the import address table (IAT). The contents of this table are identical to the contents of the import lookup table until the image is bound. |

**Bound Imports**

A bound import essentially means that the import table contains fixed address for the imported functions. These addresses are calculated and written during compile time by the linker

Using bound imports is a way to optimize performance, It reduces the time the loader needs to resolve function addresses and fill the IAT. However if at run-time the bound addresses do not match the real ones then the loader will have to resolve addresses again and refill in the IAT

**Import Lookup Table (ILT) (or Import Name Table (INT))**

An ILT is an array of 32-bit numbers (PE32) and 64-bit numbers (PE32+). Each entry uses the bit-field format as following table. 

| Bit(s) | Size | Bit field | Description |
| --- | --- | --- | --- |
| 31/63 | 1 | Ordinal/Name Flag | If this bit is set, import by ordinal. Otherwise, import by name. Bit is masked as 0x80000000 for PE32, 0x8000000000000000 for PE32+. |
| 15-0 | 16 | Ordinal Number | A 16-bit ordinal number. This field is used only if the Ordinal/Name Flag bit field is 1 (import by ordinal). Bits 30-15 or 62-15 must be 0. |
| 30-0 | 31 | Hint/Name Table RVA | A 31-bit RVA of a hint/name table entry. This field is used only if the Ordinal/Name Flag bit field is 0 (import by name). For PE32+ bits 62-31 must be zero. |

In this format, bit 31 is MSB for PE32 and 63 is the same for PE32+, the last entry is set to zero (NULL) to mark the end of table

**Hint/Name Table**

```cpp
**typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    CHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;**
```

| Offset | Size | Field | Description |
| --- | --- | --- | --- |
| 0 | 2 | Hint | An index into the export name pointer table.  |
| 2 | variable | Name | An ASCII string that contains the name to import.  |
| * | 0 or 1 | Pad | A trailing zero-pad byte that appears after the trailing null byte, or align the next entry |

**Import Address Table (IAT)**

On disk, the IAT is identical to the ILT, however during bounding when the binary is being loaded into memory (RAM), the entries of the IAT get overwritten with the addresses of the functions that are being imported.

Here’s the import Directory Table of the actual PE file in PE-bear:

![{A050C585-A82D-4006-B421-C940C1945EE0}.png](/assets/images/courses/malware/chapter2/A050C585-A82D-4006-B421-C940C1945EE0.png)

### PE Base Relocations

**Relocations**

When a program is compiled, the compiler/linker assumes that the executable will be located at a specific base address, that address is stored in `IMAGE_OPTIONAL_HEADER.ImageBase` , some addresses inside the code and data are generated relative to the base address by default

However, this base addresses very likely to be unavailable at runtime, because when Windows loads the executables, the preferred base address may already be occupied by another module or is mapped to a different location in memory.

So, that is why the Relocation Table exist (it is referenced by a Data Directory and is located in the `.reloc` section). The relocation table stores a list of locations that contains base-dependent addresses. 

When the loader loads image, it calculates (we will call it “Delta”) the difference between the base address and the actual load address. Then, the loader adds this Delta to all relocation location so that the addresses become valid at the actual load address.

As a result, the program can execute even when it is loaded at a different base address.

**Relocation Table**

As described by Microsoft documentation, the base relocation table contains entries for all base relocations in the image. It’s a Data Directory located within the `.reloc` section, it’s divided into blocks, each block represents the base relocations for a 4K page and each block must start on a 32-bit boundary.

Each block starts with an `IMAGE_BASE_RELOCATION` structure followed by any number of offset field entries.

| **Header (Always 8 bytes)** | **Body (Any number of entries)** |
| --- | --- |
| IMAGE_BASE_RELOCATION | [Entry 1] [Entry 2] [Entry 3] ... [Entry N] |

The definition of Relocation Table in `winnt.h` :

```c
typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;
```

Each offset field entry is a WORD: first 4 bits define the relocation type, and the remaining bits store an offset relative to the RVA at the start of the relocation block.

The Relocation Table in actual PE file may look likes this:

![{E054BF36-9CC4-46B2-B216-D758B1F1B8CE}.png](/assets/images/courses/malware/chapter2/E054BF36-9CC4-46B2-B216-D758B1F1B8CE.png)

As you can see, we can calculate the number of entries as follows:

The Block size is 0x11C. So the Size of relocation block header is always 8 bytes, and the Size of entry is 2 bytes.

We have formula:

$$
Entries = \frac{BlockSize  - Header}{SizeOfEntry}
$$

After applying the formula above, we can calculate the number of entries, which match the value in the picture.
